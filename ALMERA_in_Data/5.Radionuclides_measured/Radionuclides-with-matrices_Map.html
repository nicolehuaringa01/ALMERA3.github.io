<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALMERA Radionuclides Map</title>
    <!-- Load D3 and TopoJSON from a CDN -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            background-color: #f7fafc;
        }
        #chart-container {
            position: relative;
            max-width: 900px;
            margin: 20px auto;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            overflow: hidden;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background-color: #e2e8f0;
            border-radius: 0.5rem;
        }
        #tooltip {
            position: absolute;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            font-family: inherit;
            display: none;
        }
    </style>
</head>
<body>
    <div id="chart-container" class="space-y-4">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800">Interactive ALMERA Laboratories</h1>
        <input type="text" id="search-bar" placeholder="Search by Radionuclide, Laboratory, Member State, or City..." class="w-full px-4 py-2 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
        <div id="map-container" class="relative w-full aspect-[2/1] bg-gray-200 rounded-lg overflow-hidden">
            <canvas id="map-canvas" class="w-full h-full"></canvas>
            <div id="tooltip" class="absolute z-10 p-2 bg-black bg-opacity-70 text-white rounded-lg shadow-lg"></div>
        </div>
    </div>

    <script>
        // Use an async function to handle all data loading and chart initialization
        async function initializeRadionuclidesChart() {
            // --- Configuration and Constants ---
            const container = document.getElementById("chart-container");
            const canvas = document.getElementById("map-canvas");
            const context = canvas.getContext("2d");
            const tooltip = document.getElementById("tooltip");
            const searchBar = document.getElementById("search-bar");

            const width = container.clientWidth;
            const height = width / 2; // Maintain a 2:1 aspect ratio
            canvas.width = width;
            canvas.height = height;

            // --- Data Loading ---
            // Load map and data files asynchronously. Update the CSV path to your file.
            const [land, sphere, data] = await Promise.all([
                d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/land-50m.json").then(topojson.feature, err => { console.error("Error loading land data:", err); return null; }),
                d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/sphere.json").then(topojson.feature, err => { console.error("Error loading sphere data:", err); return null; }),
                d3.csv("/ALMERA3.github.io/data/almeraMembersPrivateCopyRadionuclides.csv")
            ]);

            if (!land || !sphere || !data) {
                console.error("Failed to load all required data.");
                container.innerHTML = "<p class='text-red-500 text-center'>Failed to load map or data. Please check the console for details.</p>";
                return;
            }

            // Maintain a filtered version of the data; initially, all data is shown.
            let filteredData = data;
            let selectedPoint = null;

            // Create a color scale for the Geographic Region
            const colorScale = d3.scaleOrdinal()
                .domain(["EUROPE", "NORTH AND LATIN AMERICA", "ASIA PACIFIC", "AFRICA", "MIDDLE EAST"])
                .range(["#d9534f", "#428bca", "#5cb85c", "#f0ad4e", "#5bc0de"]); // Using a nicer color palette

            // Define the geographic projection
            let projection = d3.geoEqualEarth().fitSize([width, height], land);
            let path = d3.geoPath(projection, context);

            // Clustering function to group nearby points
            function clusterPoints(points, radius) {
                const clusters = [];
                points.forEach(point => {
                    let addedToCluster = false;
                    clusters.forEach(cluster => {
                        const dx = point.x - cluster.x;
                        const dy = point.y - cluster.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < radius) {
                            cluster.points.push(point);
                            cluster.x = (cluster.x * (cluster.points.length - 1) + point.x) / cluster.points.length;
                            cluster.y = (cluster.y * (cluster.points.length - 1) + point.y) / cluster.points.length;
                            addedToCluster = true;
                        }
                    });
                    if (!addedToCluster) {
                        clusters.push({ x: point.x, y: point.y, points: [point] });
                    }
                });
                return clusters;
            }

            // Function to render the map and dots
            function render() {
                // Clear the canvas
                context.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the sphere (background)
                context.beginPath();
                path(sphere);
                context.fillStyle = "#e2e8f0";
                context.fill();

                // Draw the land with a nice blue color
                context.beginPath();
                path(land);
                context.fillStyle = "#66a5d2";
                context.fill();

                // Project the data points to the canvas coordinates
                const points = filteredData.map(d => {
                    const [x, y] = projection([+d.Long, +d.Lat]) || [];
                    return {
                        x, y,
                        color: colorScale(d["Geographic Region"] || "black"),
                        info: d["Laboratory Name"] || "Laboratory Missing",
                        city: d["City"] || "Unknown City",
                        memberState: d["Member State"] || "No member state",
                        contact: d["Contact Person"] || "No contact available",
                        telephone: d["Telephone"] || "No telephone available",
                        email: d["Email"] || "No email available",
                        address: d["Physical Address"] || "No address available",
                        update: d["Latest Update"] || "Unknown update",
                        radionuclides: d["Radionuclides"] || "No info on file"
                    };
                }).filter(d => d.x && d.y); // Filter out points that fall outside the projection

                // Cluster points to avoid overlap
                const clusters = clusterPoints(points, 15);

                clusters.forEach(cluster => {
                    if (cluster.points.length > 1) {
                        // Draw a cluster circle
                        context.beginPath();
                        context.arc(cluster.x, cluster.y, 10, 0, 2 * Math.PI);
                        context.fillStyle = "gray";
                        context.fill();
                        context.fillStyle = "white";
                        context.textAlign = "center";
                        context.textBaseline = "middle";
                        context.font = "12px Arial";
                        context.fillText(cluster.points.length, cluster.x, cluster.y);
                    } else {
                        const point = cluster.points[0];
                        context.beginPath();
                        context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                        context.fillStyle = point.color;
                        context.fill();
                    }
                });

                return points;
            }

            // Initial render with all data
            let renderedPoints = render();

            // --- Event Listeners ---

            // Search bar functionality
            searchBar.addEventListener("input", function() {
                const query = this.value.toLowerCase();
                filteredData = data.filter(d =>
                    (d["Member State"] && d["Member State"].toLowerCase().includes(query)) ||
                    (d["Laboratory Name"] && d["Laboratory Name"].toLowerCase().includes(query)) ||
                    (d["Geographic Region"] && d["Geographic Region"].toLowerCase().includes(query)) ||
                    (d["Contact Person"] && d["Contact Person"].toLowerCase().includes(query)) ||
                    (d["City"] && d["City"].toLowerCase().includes(query)) ||
                    (d["Radionuclides"] && d["Radionuclides"].toLowerCase().includes(query))
                );
                renderedPoints = render();
            });

            // Mouse events for tooltips
            canvas.addEventListener("mousemove", (event) => {
                if (selectedPoint) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const hoveredPoint = renderedPoints.find(point => {
                    const dx = mouseX - point.x;
                    const dy = mouseY - point.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                });

                if (hoveredPoint) {
                    tooltip.style.display = "block";
                    tooltip.style.left = `${event.pageX + 10}px`;
                    tooltip.style.top = `${event.pageY + 10}px`;
                    tooltip.innerHTML = `
                        <strong>${hoveredPoint.info}</strong><br>
                        ğŸ¢ ${hoveredPoint.address}<br>
                        ğŸ“ ${hoveredPoint.city}<br>
                        ğŸŒ ${hoveredPoint.memberState}<br>
                        <hr class="my-1 border-gray-600">
                        ğŸ§‘â€ğŸ’¼ ${hoveredPoint.contact}<br>
                        ğŸ“§ ${hoveredPoint.email}<br>
                        ğŸ“ ${hoveredPoint.telephone}<br>
                        <hr class="my-1 border-gray-600">
                        <span class="font-semibold">Radionuclides:</span><br>
                        ${hoveredPoint.radionuclides.split(';').join('<br>')}
                    `;
                } else {
                    tooltip.style.display = "none";
                }
            });

            canvas.addEventListener("click", (event) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const clickedPoint = renderedPoints.find(point => {
                    const dx = mouseX - point.x;
                    const dy = mouseY - point.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                });

                if (clickedPoint) {
                    selectedPoint = clickedPoint;
                    tooltip.style.display = "block";
                    tooltip.style.left = `${event.pageX + 10}px`;
                    tooltip.style.top = `${event.pageY + 10}px`;
                    tooltip.innerHTML = `
                        <strong>${clickedPoint.info}</strong><br>
                        ğŸ¢ ${clickedPoint.address}<br>
                        ğŸ“ ${clickedPoint.city}<br>
                        ğŸŒ ${clickedPoint.memberState}<br>
                        <hr class="my-1 border-gray-600">
                        ğŸ§‘â€ğŸ’¼ ${clickedPoint.contact}<br>
                        ğŸ“§ ${clickedPoint.email}<br>
                        ğŸ“ ${clickedPoint.telephone}<br>
                        <hr class="my-1 border-gray-600">
                        <span class="font-semibold">Radionuclides:</span><br>
                        ${clickedPoint.radionuclides.split(';').join('<br>')}
                    `;
                } else {
                    selectedPoint = null;
                    tooltip.style.display = "none";
                }
            });

            // Handle responsiveness
            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                canvas.width = newWidth;
                canvas.height = newWidth / 2;
                projection.fitSize([canvas.width, canvas.height], land);
                path = d3.geoPath(projection, context);
                render();
            });

            // Handle zooming
            const zoom = d3.zoom()
                .scaleExtent([1, 250])
                .on("zoom", (event) => {
                    const transform = event.transform;
                    projection.translate([transform.x, transform.y]).scale(transform.k * (canvas.width / 2 / Math.PI));
                    renderedPoints = render();
                });

            d3.select(canvas)
                .call(zoom)
                .on("dblclick.zoom", null);
        }

        // Initialize the chart once the DOM is ready
        document.addEventListener("DOMContentLoaded", initializeRadionuclidesChart);
    </script>
</body>
</html>
